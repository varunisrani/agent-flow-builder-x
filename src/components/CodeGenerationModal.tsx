import { useState, useEffect } from 'react';
import { Node, Edge } from '@xyflow/react';
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
  DialogFooter,
} from '@/components/ui/dialog';
import { Button } from '@/components/ui/button';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
import { BaseNodeData } from './nodes/BaseNode';
import { Copy, AlertCircle, Loader2 } from 'lucide-react';
import { toast } from '@/hooks/use-toast';
import { generateCode } from '@/lib/codeGenerator';

// Add the CodeBlock component for syntax highlighting
const CodeBlock = ({ code }: { code: string }) => {
  // Create syntax highlighted version by adding span elements with appropriate classes
  // This is a simple implementation - in a real app you might use a library like highlight.js or prism
  const highlightedCode = code
    // Highlight keywords
    .replace(
      /\b(import|from|def|class|if|else|try|except|return|for|in|as|with|print|self|None|True|False|and|or|not|while|break|continue|pass|raise|finally|assert|yield|lambda)\b/g,
      '<span class="text-purple-500">$1</span>'
    )
    // Highlight strings
    .replace(
      /(".*?"|'.*?')/g,
      '<span class="text-amber-500">$1</span>'
    )
    // Highlight comments
    .replace(
      /(#.*)/g,
      '<span class="text-gray-500">$1</span>'
    )
    // Highlight function calls
    .replace(
      /(\w+)(\()/g,
      '<span class="text-blue-500">$1</span>$2'
    )
    // Highlight special Python decorators
    .replace(
      /(@\w+)/g,
      '<span class="text-green-500">$1</span>'
    )
    // Highlight constants (UPPERCASE_VARIABLES)
    .replace(
      /\b([A-Z_]{2,})\b/g,
      '<span class="text-cyan-500">$1</span>'
    )
    // Highlight numbers
    .replace(
      /\b(\d+)\b/g,
      '<span class="text-red-400">$1</span>'
    );

  return (
    <pre className="p-4 bg-gray-900 text-gray-100 rounded-md overflow-auto max-h-96 font-mono text-sm">
      <code dangerouslySetInnerHTML={{ __html: highlightedCode }} />
    </pre>
  );
};

interface CodeGenerationModalProps {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  nodes: Node<BaseNodeData>[];
  edges: Edge[];
}

export function CodeGenerationModal({
  open,
  onOpenChange,
  nodes,
  edges,
}: CodeGenerationModalProps) {
  const [activeTab, setActiveTab] = useState<string>('adk');
  const [generatedCode, setGeneratedCode] = useState<string>('');
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  // Generate code when the modal opens or when nodes/edges change
  useEffect(() => {
    async function fetchCode() {
      if (!open) return;
      
      setLoading(true);
      setError(null);
      
      try {
        // Convert the activeTab to the framework type
        const framework = activeTab as 'adk' | 'vertex' | 'custom';
        
        // Use OpenAI to generate code based on the nodes and edges
        const code = await generateCode(nodes, edges, framework);
        setGeneratedCode(code);
      } catch (error) {
        console.error('Error generating code:', error);
        setError(error instanceof Error ? error.message : 'An error occurred generating code');
        // Fallback to the local code generation
        setGeneratedCode(getLocallyGeneratedCode(nodes, edges, activeTab));
      } finally {
        setLoading(false);
      }
    }
    
    fetchCode();
  }, [open, nodes, edges, activeTab]);

  const handleCopyCode = () => {
    navigator.clipboard.writeText(generatedCode);
    toast({
      title: "Code copied!",
      description: "The generated code has been copied to your clipboard.",
    });
  };

  // Fallback code generation function that uses local logic if the API fails
  const getLocallyGeneratedCode = (nodes: Node<BaseNodeData>[], edges: Edge[], framework: string) => {
    switch (framework) {
      case 'adk':
        return generateAgentCode(nodes, edges);
      case 'vertex':
        return generateVertexCode(nodes, edges);
      case 'custom':
        return generateCustomAgentCode(nodes, edges);
      default:
        return generateAgentCode(nodes, edges);
    }
  };

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="sm:max-w-4xl">
        <DialogHeader>
          <DialogTitle>Generated Agent Code</DialogTitle>
          <DialogDescription>
            This code represents the agent flow you've designed. The code is generated by AI based on your workflow diagram.
          </DialogDescription>
        </DialogHeader>

        <Tabs defaultValue="adk" value={activeTab} onValueChange={setActiveTab}>
          <TabsList>
            <TabsTrigger value="adk">Google ADK</TabsTrigger>
            <TabsTrigger value="vertex">Vertex AI</TabsTrigger>
            <TabsTrigger value="custom">Custom Agent</TabsTrigger>
          </TabsList>
          
          <TabsContent value={activeTab} className="mt-4">
            <div className="relative">
              {error && (
                <div className="mb-2 p-2 bg-red-100 border border-red-200 rounded-md text-red-800 text-sm flex items-center gap-2">
                  <AlertCircle className="h-4 w-4" />
                  <span>{error}</span>
                </div>
              )}
              {loading ? (
                <div className="flex items-center justify-center h-40 gap-2 bg-gray-900 rounded-md text-gray-200">
                  <Loader2 className="h-5 w-5 animate-spin text-primary" />
                  <span>Generating code...</span>
                </div>
              ) : (
                <div className="relative">
                  <CodeBlock code={generatedCode} />
                  <Button
                    size="sm"
                    variant="ghost"
                    className="absolute top-2 right-2 bg-gray-800/70 hover:bg-gray-800/90"
                    onClick={handleCopyCode}
                    disabled={loading}
                  >
                    <Copy className="h-4 w-4 text-gray-200" />
                  </Button>
                </div>
              )}
            </div>
            
            <div className="mt-2 text-xs text-muted-foreground">
              <strong>Note:</strong> The generated code uses {activeTab === 'adk' 
                ? "Google's Agent Development Kit" 
                : activeTab === 'vertex' 
                  ? "Google Vertex AI"
                  : "a custom OpenAI-based framework"}.
              You may need to install the appropriate packages and credentials.
            </div>
          </TabsContent>
        </Tabs>

        <DialogFooter className="flex justify-between items-center">
          <div className="text-xs text-muted-foreground">
            Powered by GPT-4.1 Mini
          </div>
          <div className="flex gap-2">
            <Button 
              disabled={loading} 
              onClick={() => {
                setLoading(true);
                setError(null);
                
                generateCode(nodes, edges, activeTab as 'adk' | 'vertex' | 'custom')
                  .then(code => {
                    setGeneratedCode(code);
                    toast({
                      title: "Code regenerated",
                      description: "The code has been regenerated with the latest AI model."
                    });
                  })
                  .catch(err => {
                    console.error('Error regenerating code:', err);
                    setError(err instanceof Error ? err.message : 'Failed to regenerate code');
                  })
                  .finally(() => setLoading(false));
              }}
            >
              {loading ? <Loader2 className="h-4 w-4 animate-spin mr-2" /> : null}
              {loading ? "Generating..." : "Regenerate Code"}
            </Button>
            <Button variant="outline" onClick={() => onOpenChange(false)}>
              Close
            </Button>
          </div>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}

// Code generation functions
function generateAgentCode(nodes: Node<BaseNodeData>[], edges: Edge[], type: string = 'adk'): string {
  // Find agent nodes
  const agentNodes = nodes.filter(node => node.data.type === 'agent');
  const modelNodes = nodes.filter(node => node.data.type === 'model');
  const toolNodes = nodes.filter(node => node.data.type === 'tool');
  const functionNodes = nodes.filter(node => node.data.type === 'function');
  
  let code = `from google.adk.agents import Agent\n`;
  
  // Import needed libraries
  if (toolNodes.length > 0) {
    code += `from google.adk.tools import google_search\n`;
  }
  
  if (functionNodes.length > 0) {
    code += `\n# Custom function definitions\n`;
    functionNodes.forEach(node => {
      code += `def ${node.data.label.toLowerCase().replace(/\s+/g, '_')}(input: str) -> dict:\n`;
      code += `    # Implementation for ${node.data.label}\n`;
      code += `    return {"status": "success", "result": f"Processed {input}"}\n\n`;
    });
  }
  
  // Generate agent code
  code += `\n# Create agent\n`;
  if (agentNodes.length > 0) {
    const mainAgent = agentNodes[0];
    const connectedModelId = edges.find(edge => edge.source === mainAgent.id)?.target || '';
    const connectedModel = nodes.find(node => node.id === connectedModelId);
    const modelName = connectedModel?.data?.modelType || 'gemini-2.0-flash';
    
    // Find connected tools
    const connectedToolIds = edges
      .filter(edge => edge.target === mainAgent.id)
      .map(edge => edge.source);
    
    const connectedTools = connectedToolIds.map(id => 
      nodes.find(node => node.id === id)
    ).filter(Boolean);
    
    const toolList = connectedTools.length > 0 
      ? `[${connectedTools.map(tool => tool?.data.label.toLowerCase().replace(/\s+/g, '_')).join(', ')}]` 
      : '[]';
    
    code += `${mainAgent.data.label.toLowerCase().replace(/\s+/g, '_')} = Agent(\n`;
    code += `    name="${mainAgent.data.label.toLowerCase().replace(/\s+/g, '_')}",\n`;
    code += `    model="${modelName}",\n`;
    code += `    description="${mainAgent.data.description || 'An AI agent'}",\n`;
    code += `    instruction="${mainAgent.data.instruction || 'I am a helpful assistant.'}",\n`;
    code += `    tools=${toolList}\n`;
    code += `)\n`;
    
    // Add usage example
    code += `\n# Example usage\n`;
    code += `response = ${mainAgent.data.label.toLowerCase().replace(/\s+/g, '_')}.generate("Hello, how can you help me today?")\n`;
    code += `print(response)\n`;
  } else {
    code += `# No agent nodes found in your flow. Add an agent node to generate code.\n`;
    code += `\n# Example agent code\n`;
    code += `example_agent = Agent(\n`;
    code += `    name="example_agent",\n`;
    code += `    model="gemini-2.0-flash",\n`;
    code += `    description="A helpful assistant agent that can answer questions.",\n`;
    code += `    instruction="I am a helpful assistant that provides accurate and detailed information.",\n`;
    code += `    tools=[]\n`;
    code += `)\n\n`;
    code += `# Example usage\n`;
    code += `response = example_agent.generate("Hello, how can you help me today?")\n`;
    code += `print(response)\n`;
  }
  
  return code;
}

function generateVertexCode(nodes: Node<BaseNodeData>[], edges: Edge[]): string {
  // Generate Vertex AI code
  let code = `from google.cloud import aiplatform\n\n`;
  code += `# Initialize the Vertex AI SDK\n`;
  code += `aiplatform.init(project="your-project-id", location="your-location")\n\n`;
  
  // Find agent nodes
  const agentNodes = nodes.filter(node => node.data.type === 'agent');
  
  if (agentNodes.length > 0) {
    const mainAgent = agentNodes[0];
    
    code += `# Create an agent\n`;
    code += `agent = aiplatform.Agent.create(\n`;
    code += `    display_name="${mainAgent.data.label}",\n`;
    code += `    model="gemini-pro"\n`;
    code += `)\n\n`;
    
    code += `# Interact with the agent\n`;
    code += `response = agent.chat("Hello, how can I assist you today?")\n`;
    code += `print(response)\n`;
  } else {
    code += `# No agent nodes found in your flow. Add an agent node to generate code.\n`;
    code += `\n# Example agent code\n`;
    code += `agent = aiplatform.Agent.create(\n`;
    code += `    display_name="My Vertex AI Agent",\n`;
    code += `    model="gemini-pro"\n`;
    code += `)\n\n`;
    code += `# Interact with the agent\n`;
    code += `response = agent.chat("Hello, how can I assist you today?")\n`;
    code += `print(response)\n`;
  }
  
  return code;
}

function generateCustomAgentCode(nodes: Node<BaseNodeData>[], edges: Edge[]): string {
  // Generate code for a custom agent using tools
  const functionNodes = nodes.filter(node => node.data.type === 'function' || node.data.type === 'tool');
  const agentNodes = nodes.filter(node => node.data.type === 'agent');
  const modelNodes = nodes.filter(node => node.data.type === 'model');
  
  let code = `import openai
import json
from typing import Dict, List, Any, Optional

# Set your OpenAI API key
openai.api_key = "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"

`;
  
  // Add custom tool definitions
  if (functionNodes.length > 0) {
    code += `# Define custom tools\n`;
    functionNodes.forEach(node => {
      const toolName = node.data.label.toLowerCase().replace(/\s+/g, '_');
      code += `def ${toolName}(params: Dict[str, Any]) -> Dict[str, Any]:\n`;
      code += `    """${node.data.description || `Implementation for ${node.data.label}`}\n`;
      code += `    \n`;
      code += `    Args:\n`;
      code += `        params: Parameters for the tool\n`;
      code += `    \n`;
      code += `    Returns:\n`;
      code += `        Result of the tool execution\n`;
      code += `    """\n`;
      code += `    # TODO: Implement ${node.data.label} functionality\n`;
      code += `    return {"result": f"Executed ${toolName} with {params}"}\n\n`;
    });
    
    // Add tools registry
    code += `# Register all available tools\n`;
    code += `TOOLS = {\n`;
    functionNodes.forEach(node => {
      const toolName = node.data.label.toLowerCase().replace(/\s+/g, '_');
      code += `    "${toolName}": ${toolName},\n`;
    });
    code += `}\n\n`;
  }
  
  // Create agent class
  code += `class Agent:\n`;
  code += `    def __init__(self, name: str, model: str = "gpt-4.1-mini", tools: Optional[List[str]] = None):\n`;
  code += `        self.name = name\n`;
  code += `        self.model = model\n`;
  code += `        self.tools = tools or []\n`;
  code += `        self.conversation_history = []\n`;
  code += `    \n`;
  code += `    def add_message(self, role: str, content: str, name: Optional[str] = None) -> None:\n`;
  code += `        """Add a message to the conversation history."""\n`;
  code += `        message = {"role": role, "content": content}\n`;
  code += `        if name:\n`;
  code += `            message["name"] = name\n`;
  code += `        self.conversation_history.append(message)\n`;
  code += `    \n`;
  code += `    def generate(self, user_input: str) -> str:\n`;
  code += `        """Generate a response to the user input using the configured model."""\n`;
  code += `        # Add user message to history\n`;
  code += `        self.add_message("user", user_input)\n`;
  code += `        \n`;
  code += `        try:\n`;
  code += `            # Prepare available tools for the model\n`;
  code += `            available_tools = []\n`;
  code += `            for tool_name in self.tools:\n`;
  code += `                if tool_name in TOOLS:\n`;
  code += `                    tool_fn = TOOLS[tool_name]\n`;
  code += `                    available_tools.append({\n`;
  code += `                        "type": "function",\n`;
  code += `                        "function": {\n`;
  code += `                            "name": tool_name,\n`;
  code += `                            "description": tool_fn.__doc__,\n`;
  code += `                            "parameters": {\n`;
  code += `                                "type": "object",\n`;
  code += `                                "properties": {\n`;
  code += `                                    "params": {\n`;
  code += `                                        "type": "object",\n`;
  code += `                                        "description": "The parameters for the function"\n`;
  code += `                                    }\n`;
  code += `                                },\n`;
  code += `                                "required": ["params"]\n`;
  code += `                            }\n`;
  code += `                        }\n`;
  code += `                    })\n`;
  code += `            \n`;
  code += `            # Call the model\n`;
  code += `            response = openai.chat.completions.create(\n`;
  code += `                model=self.model,\n`;
  code += `                messages=self.conversation_history,\n`;
  code += `                tools=available_tools if available_tools else None,\n`;
  code += `                tool_choice="auto"\n`;
  code += `            )\n`;
  code += `            \n`;
  code += `            assistant_message = response.choices[0].message\n`;
  code += `            \n`;
  code += `            # Check if the model wants to call a tool\n`;
  code += `            if hasattr(assistant_message, "tool_calls") and assistant_message.tool_calls:\n`;
  code += `                # Add the assistant's message to the history\n`;
  code += `                self.add_message("assistant", assistant_message.content or "")\n`;
  code += `                \n`;
  code += `                # Handle each tool call\n`;
  code += `                for tool_call in assistant_message.tool_calls:\n`;
  code += `                    function_name = tool_call.function.name\n`;
  code += `                    function_args = json.loads(tool_call.function.arguments)\n`;
  code += `                    \n`;
  code += `                    if function_name in TOOLS:\n`;
  code += `                        # Execute the tool\n`;
  code += `                        tool_result = TOOLS[function_name](function_args.get("params", {}))\n`;
  code += `                        \n`;
  code += `                        # Add the tool result to history\n`;
  code += `                        self.add_message(\n`;
  code += `                            "tool",\n`;
  code += `                            json.dumps(tool_result),\n`;
  code += `                            name=function_name\n`;
  code += `                        )\n`;
  code += `                \n`;
  code += `                # Get a new response from the model that takes into account the tool results\n`;
  code += `                try:\n`;
  code += `                    second_response = openai.chat.completions.create(\n`;
  code += `                        model=self.model,\n`;
  code += `                        messages=self.conversation_history\n`;
  code += `                    )\n`;
  code += `                    \n`;
  code += `                    final_content = second_response.choices[0].message.content\n`;
  code += `                    self.add_message("assistant", final_content or "")\n`;
  code += `                    return final_content or ""\n`;
  code += `                except Exception as e:\n`;
  code += `                    print(f"Error getting second response: {e}")\n`;
  code += `                    return "Error processing tool results. Please try again."\n`;
  code += `            else:\n`;
  code += `                # No tool calls, just return the response\n`;
  code += `                content = assistant_message.content or ""\n`;
  code += `                self.add_message("assistant", content)\n`;
  code += `                return content\n`;
  code += `        except Exception as e:\n`;
  code += `            print(f"Error in generate method: {e}")\n`;
  code += `            return f"An error occurred: {str(e)}"\n\n`;
  
  // Create the agent instance
  if (agentNodes.length > 0) {
    const mainAgent = agentNodes[0];
    
    // Find the model used by the agent
    let modelName = "gpt-4.1-mini";  // Default
    const connectedModelEdge = edges.find(edge => 
      (edge.source === mainAgent.id || edge.target === mainAgent.id) && 
      nodes.find(n => (n.id === edge.target || n.id === edge.source) && n.data.type === 'model')
    );
    
    if (connectedModelEdge) {
      const modelId = connectedModelEdge.source === mainAgent.id ? connectedModelEdge.target : connectedModelEdge.source;
      const connectedModel = nodes.find(node => node.id === modelId);
      if (connectedModel && connectedModel.data.modelType) {
        modelName = connectedModel.data.modelType;
      }
    }
    
    // Find tools used by the agent - check connections in both directions
    const toolNames = [];
    
    // Tools connected to the agent (agent -> tool or tool -> agent)
    edges.forEach(edge => {
      const isFromAgent = edge.source === mainAgent.id;
      const isToAgent = edge.target === mainAgent.id;
      
      if (isFromAgent || isToAgent) {
        const toolId = isFromAgent ? edge.target : edge.source;
        const tool = nodes.find(n => n.id === toolId && (n.data.type === 'tool' || n.data.type === 'function'));
        
        if (tool && !toolNames.includes(tool.data.label.toLowerCase().replace(/\s+/g, '_'))) {
          toolNames.push(tool.data.label.toLowerCase().replace(/\s+/g, '_'));
        }
      }
    });
    
    code += `# Create an instance of the agent\n`;
    code += `agent = Agent(\n`;
    code += `    name="${mainAgent.data.label.toLowerCase().replace(/\s+/g, '_')}",\n`;
    code += `    model="${modelName}",\n`;
    code += `    tools=[${toolNames.map(name => `"${name}"`).join(', ')}]\n`;
    code += `)\n\n`;
    
    code += `# Example usage\n`;
    code += `if __name__ == "__main__":\n`;
    code += `    try:\n`;
    code += `        response = agent.generate("Hello, can you help me with something?")\n`;
    code += `        print(response)\n`;
    code += `    except Exception as e:\n`;
    code += `        print(f"Error running agent: {e}")\n`;
  } else {
    code += `# Create a default agent instance\n`;
    code += `agent = Agent(\n`;
    code += `    name="default_agent",\n`;
    code += `    model="gpt-4.1-mini",\n`;
    code += `    tools=[]\n`;
    code += `)\n\n`;
    
    code += `# Example usage\n`;
    code += `if __name__ == "__main__":\n`;
    code += `    try:\n`;
    code += `        response = agent.generate("Hello, can you help me with something?")\n`;
    code += `        print(response)\n`;
    code += `    except Exception as e:\n`;
    code += `        print(f"Error running agent: {e}")\n`;
  }
  
  return code;
}
