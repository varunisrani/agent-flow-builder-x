import 'dotenv/config';
import express from 'express';
import bodyParser from 'body-parser';
import cors from 'cors';
import { Sandbox } from '@e2b/code-interpreter';

// Create Express server
const app = express();
const PORT = process.env.PORT || 3001;

// CORS middleware with proper configuration
app.use(cors({
  origin: '*', // Allow all origins
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
  allowedHeaders: ['X-Requested-With', 'Content-Type', 'Accept', 'Authorization'],
  credentials: true,
  preflightContinue: false,
  optionsSuccessStatus: 204
}));

// Handle OPTIONS requests explicitly
app.options('*', (req, res) => {
  res.status(204).end();
});

// Middleware
app.use(bodyParser.json({ limit: '50mb' }));
app.use(bodyParser.urlencoded({ limit: '50mb', extended: true }));

// Execute code in sandbox endpoint
app.post('/api/execute', async (req, res) => {
  const startTime = Date.now();
  console.log('\nüöÄ Starting code execution request...');
  console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
  
  try {
    const { files } = req.body;
    
    if (!files || !files['agent.py']) {
      console.log('‚ùå Error: No agent.py file provided');
      return res.status(400).json({ error: 'No agent.py file provided' });
    }

    console.log('üìù Files to create:');
    console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
    Object.entries(files).forEach(([filename, content]) => {
      console.log(`‚Ä¢ ${filename} (${content.length} characters)`);
    });
    console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n');

    // Create sandbox instance
    console.log('üèóÔ∏è Creating sandbox instance...');
    const sbx = await Sandbox.create({
      metadata: {
        template: 'base',
        name: 'agent-flow-builder-sandbox'
      }
    });
    console.log('‚úÖ Sandbox created successfully\n');

    try {
      // Create the agent_package directory
      console.log('üìÅ Creating agent_package directory...');
      await sbx.commands.run('mkdir -p workspace/agent_package');
      console.log('‚úÖ Agent package directory created\n');

      // Write files to the sandbox
      console.log('üìù Writing files to sandbox...');
      for (const [filename, content] of Object.entries(files)) {
        // Validate Python syntax for .py files
        if (filename.endsWith('.py') && filename === 'agent.py') {
          try {
            const validationScript = `
import ast
import sys

code = '''${content.replace(/'/g, "\\'")}'''

try:
    ast.parse(code)
    print("‚úÖ Python syntax validation passed")
    sys.exit(0)
except SyntaxError as e:
    print(f"‚ùå Python syntax error: {e}")
    sys.exit(1)
except Exception as e:
    print(f"‚ùå Python validation error: {e}")
    sys.exit(1)
`;
            
            // Write and run the validation script
            await sbx.files.write('workspace/validate_syntax.py', validationScript);
            const syntaxCheck = await sbx.commands.run('cd workspace && python3 validate_syntax.py');
            
            if (syntaxCheck.exitCode !== 0) {
              console.error('‚ùå Python syntax validation failed:', syntaxCheck.stdout);
              return res.status(400).json({ 
                error: `Python syntax error in ${filename}: ${syntaxCheck.stdout}`,
                executionTime: Date.now() - startTime
              });
            }
            console.log('‚úÖ Python syntax validation passed for agent.py');
          } catch (validationError) {
            console.warn('‚ö†Ô∏è Could not validate Python syntax, proceeding anyway:', validationError.message);
          }
        }
        
        await sbx.files.write(`workspace/agent_package/${filename}`, content);
        console.log(`‚úÖ Created ${filename}`);
      }
      
      // Create enhanced __init__.py file to make agent_package a proper Python package
      console.log('üìù Creating enhanced __init__.py file...');
      const initContent = `"""
Agent Package

This package contains an ADK-compatible agent that can be discovered
and launched by the Google Agent Development Kit (ADK) web interface.

Generated by Agent Flow Builder
"""

from .agent import root_agent

__all__ = ["root_agent"]
__version__ = "1.0.0"
__author__ = "Agent Flow Builder"
__description__ = "Generated agent package for Google ADK"
`;
      await sbx.files.write('workspace/agent_package/__init__.py', initContent);
      console.log('‚úÖ Created enhanced __init__.py file');
      console.log('‚úÖ All files written successfully\n');

      // Set up Python environment with a compatible Python version
      console.log('üêç Setting up Python environment...');
      console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
      
      // Check Python versions available in the sandbox
      console.log('üìä Checking available Python versions...');
      const pythonVersions = await sbx.commands.run('python3 --version && python --version 2>/dev/null || echo "Python 2 not available"');
      console.log('  ‚Ä¢ Available versions:', pythonVersions.stdout);
      
      // Create virtual environment with Python 3
      console.log('üèóÔ∏è Creating virtual environment...');
      const venvResult = await sbx.commands.run('cd workspace && python3 -m venv venv');
      if (venvResult.exitCode !== 0) {
        console.error('‚ùå Failed to create virtual environment:', venvResult.stderr);
        throw new Error('Failed to create Python virtual environment');
      }
      console.log('‚úÖ Virtual environment created');
      
      // Install Google ADK in the virtual environment
      console.log('üì¶ Installing Google ADK...');
      const pipResult = await sbx.commands.run('cd workspace && source venv/bin/activate && pip install --upgrade pip && pip install google-adk', { timeoutMs: 120000 });
      
      console.log('  ‚Ä¢ Installation output:');
      if (pipResult.stdout) {
        const pipLines = pipResult.stdout.split('\n').map(line => `    ${line}`).join('\n');
        console.log(pipLines);
      }
      
      if (pipResult.stderr) {
        console.log('  ‚Ä¢ Errors/Warnings:');
        const pipErrors = pipResult.stderr.split('\n').map(line => `    ${line}`).join('\n');
        console.log(pipErrors);
      }
      
      // Verify the installation
      console.log('\nüìã Verifying installation...');
      const verifyResult = await sbx.commands.run('source workspace/venv/bin/activate && pip list | grep google-adk');
      if (verifyResult.stdout) {
        console.log(`  ‚Ä¢ Installed: ${verifyResult.stdout.trim()}`);
      } else {
        console.log('  ‚Ä¢ Warning: Could not verify google-adk installation');
      }
      
      // Create ADK config file with multiple fallback API keys
      console.log('üìù Creating ADK config file...');
      const adkConfig = {
        "api_key": process.env.GOOGLE_API_KEY || "AIzaSyABISxaNzifdIcZUCe408LoKnEz0bia8cI",
        "fallback_keys": [
          "AIzaSyB6ibSXYT7Xq7rSzHmq7MH76F95V3BCIJY",
          "AIzaSyABISxaNzifdIcZUCe408LoKnEz0bia8cI"
        ]
      };
      await sbx.files.write('workspace/adk.config.json', JSON.stringify(adkConfig, null, 2));
      console.log('‚úÖ ADK config file created with multiple API keys');
      
      console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
      console.log('‚úÖ Python environment ready\n');

      // Instead of executing the code directly, run the ADK web command
      console.log('‚ö° Starting agent with ADK web command...');
      
      try {
        // Create a .env file with multiple Google ADK API keys for fallback
        await sbx.files.write('workspace/.env', `GOOGLE_API_KEY=${process.env.GOOGLE_API_KEY || 'AIzaSyABISxaNzifdIcZUCe408LoKnEz0bia8cI'}
ADK_API_KEY=${process.env.ADK_API_KEY || process.env.GOOGLE_API_KEY || 'AIzaSyABISxaNzifdIcZUCe408LoKnEz0bia8cI'}
PYTHONUNBUFFERED=1
PYTHONPATH=/home/user/workspace:$PYTHONPATH
`);
        
        // Create a Python script to check if port is open with better timeout and debugging
        await sbx.files.write('workspace/check_port.py', `import socket
import sys
import time
import subprocess
import os

def is_port_open(host, port, timeout=3):
    """Check if a port is open on the given host"""
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(timeout)
        result = sock.connect_ex((host, port))
        sock.close()
        return result == 0
    except Exception as e:
        print(f"Error checking port {port}: {e}")
        return False

def check_adk_process():
    """Check if ADK web process is running"""
    try:
        result = subprocess.run(['pgrep', '-f', 'adk web'], capture_output=True, text=True, timeout=5)
        return result.returncode == 0 and result.stdout.strip()
    except Exception as e:
        print(f"Error checking ADK process: {e}")
        return False

def check_logs():
    """Show recent ADK logs for debugging"""
    try:
        if os.path.exists('adk_web.log'):
            print("\\nüìã Recent ADK logs:")
            with open('adk_web.log', 'r') as f:
                lines = f.readlines()
                # Show last 10 lines
                for line in lines[-10:]:
                    print(f"  {line.strip()}")
        else:
            print("No adk_web.log file found")
    except Exception as e:
        print(f"Error reading logs: {e}")

def wait_for_port(port, max_attempts=45, delay=2):
    """Wait for port to be open, with optimized timeout for ADK startup"""
    print(f"Waiting for port {port} to be available...")
    print(f"Will check every {delay} seconds for up to {max_attempts * delay} seconds")
    
    for attempt in range(max_attempts):
        elapsed = attempt * delay
        print(f"‚è≥ Attempt {attempt + 1}/{max_attempts} (elapsed: {elapsed}s)")
        
        # Check if ADK process is still running
        adk_running = check_adk_process()
        if not adk_running and attempt > 5:  # Give it some time to start
            print("‚ùå ADK web process is not running")
            check_logs()
            return False
        elif adk_running:
            print(f"‚úì ADK process is running (PID: {adk_running})")
        
        # Check if port is open
        if is_port_open('localhost', port):
            print(f"‚úÖ Port {port} is now open!")
            return True
        
        if attempt < max_attempts - 1:  # Don't sleep on the last attempt
            time.sleep(delay)
    
    print(f"‚ùå Timed out waiting for port {port} after {max_attempts * delay} seconds")
    check_logs()
    return False

if __name__ == '__main__':
    port = int(sys.argv[1]) if len(sys.argv) > 1 else 8000
    success = wait_for_port(port)
    sys.exit(0 if success else 1)
`);

        // Create an enhanced startup script with better error handling and debugging
        await sbx.files.write('workspace/start_adk.sh', `#!/bin/bash
set -e  # Exit on any error

echo "üöÄ Starting ADK agent startup process..."

# Source virtual environment
echo "üì¶ Activating virtual environment..."
source ./venv/bin/activate

# Set environment variables for Google ADK
export GOOGLE_API_KEY=\${GOOGLE_API_KEY:-${process.env.GOOGLE_API_KEY || 'AIzaSyABISxaNzifdIcZUCe408LoKnEz0bia8cI'}}
export ADK_API_KEY=\${ADK_API_KEY:-${process.env.ADK_API_KEY || process.env.GOOGLE_API_KEY || 'AIzaSyABISxaNzifdIcZUCe408LoKnEz0bia8cI'}}
export PYTHONUNBUFFERED=1

# Change to workspace directory
cd /home/user/workspace

# Validate Python code before starting server
echo "üîç Validating agent code..."
if [ -f agent_package/agent.py ]; then
    python3 -m py_compile agent_package/agent.py || {
        echo "‚ùå Python syntax error in agent.py"
        exit 1
    }
    echo "‚úÖ Agent code validation passed"
else
    echo "‚ùå agent_package/agent.py not found"
    exit 1
fi

# Check if ADK is installed correctly
echo "üîß Checking ADK installation..."
if ! command -v adk &> /dev/null; then
    echo "‚ùå ADK command not found. Attempting to install..."
    pip install --upgrade google-adk || {
        echo "‚ùå Failed to install google-adk"
        exit 1
    }
fi

# Verify ADK can be imported
python3 -c "import google.adk.agents; print('‚úÖ Google ADK is properly installed')" || {
    echo "‚ùå Google ADK import test failed"
    exit 1
}

# Kill any existing ADK web processes and clean up
echo "üßπ Cleaning up existing processes..."
pkill -f "adk web" 2>/dev/null || true
pkill -f "python.*agent_package" 2>/dev/null || true
sleep 2

# Force kill any processes using port 8000
if netstat -tuln | grep -q ":8000 "; then
    echo "‚ö†Ô∏è Port 8000 is already in use, forcefully freeing it..."
    lsof -ti:8000 | xargs kill -9 2>/dev/null || true
    sleep 3
    # Double check
    if netstat -tuln | grep -q ":8000 "; then
        echo "‚ùå Could not free port 8000, trying alternative approach..."
        fuser -k 8000/tcp 2>/dev/null || true
        sleep 2
    fi
fi

# Add the workspace directory to PYTHONPATH
export PYTHONPATH=/home/user/workspace:\$PYTHONPATH

# Create logs directory
mkdir -p logs

# Start ADK web server with enhanced configuration and retry mechanism
echo "üöÄ Starting ADK web server..."
echo "  ‚Ä¢ Host: 0.0.0.0"
echo "  ‚Ä¢ Port: 8000"
echo "  ‚Ä¢ App: agent_package"
echo "  ‚Ä¢ Python Path: \$PYTHONPATH"

# Function to start ADK server
start_adk_server() {
    local attempt=\$1
    echo "üöÄ ADK startup attempt \$attempt..."
    
    # Use a more robust startup approach
    (
        exec adk web --host 0.0.0.0 --port 8000 --app agent_package 2>&1 | tee adk_web.log
    ) &
    ADK_PID=\$!
    echo \$ADK_PID > adk_web.pid
    
    echo "üìã ADK web server started with PID: \$ADK_PID"
    
    # Give the server a moment to initialize
    sleep 8
    
    # Check if the process is still running
    if ! kill -0 \$ADK_PID 2>/dev/null; then
        echo "‚ùå ADK web server process died immediately on attempt \$attempt"
        echo "üìã Error logs:"
        tail -n 20 adk_web.log
        return 1
    fi
    
    echo "‚úÖ ADK web server process is running (attempt \$attempt)"
    return 0
}

# Try starting the server up to 3 times
MAX_ATTEMPTS=3
for attempt in \$(seq 1 \$MAX_ATTEMPTS); do
    if start_adk_server \$attempt; then
        break
    elif [ \$attempt -lt \$MAX_ATTEMPTS ]; then
        echo "‚ö†Ô∏è Attempt \$attempt failed, cleaning up and retrying..."
        pkill -f "adk web" 2>/dev/null || true
        sleep 5
    else
        echo "‚ùå All \$MAX_ATTEMPTS attempts failed"
        exit 1
    fi
done

# Wait for server to start using Python script with extended timeout
echo "‚è≥ Waiting for server to become ready..."
python3 check_port.py 8000
exit_code=\$?

if [ \$exit_code -eq 0 ]; then
    echo "üéâ ADK web server started successfully!"
    echo "üìä Server details:"
    echo "  ‚Ä¢ Host: 0.0.0.0"
    echo "  ‚Ä¢ Port: 8000"
    echo "  ‚Ä¢ App: agent_package"
    echo "  ‚Ä¢ PID: \$(cat adk_web.pid)"
    
    # Test the server endpoint
    echo "üß™ Testing server endpoint..."
    curl -s -o /dev/null -w "HTTP Status: %{http_code}\\n" http://localhost:8000/ || echo "‚ö†Ô∏è Could not test endpoint"
    
    echo "üìù Recent logs:"
    tail -n 15 adk_web.log
    exit 0
else
    echo "‚ùå Failed to start ADK web server within timeout"
    echo "üìã Process status:"
    if kill -0 \$ADK_PID 2>/dev/null; then
        echo "  ‚Ä¢ Process is still running but port not responding"
    else
        echo "  ‚Ä¢ Process has terminated"
    fi
    echo "üìù Full logs:"
    cat adk_web.log
    exit 1
fi`);
        
        // Make the script executable
        await sbx.commands.run('chmod +x workspace/start_adk.sh', { timeoutMs: 30000 });
        
        // Execute the startup script with timeout and retry mechanism
        console.log('‚ö° Starting ADK web server...');
        let adkWebResult;
        let retryCount = 0;
        const maxRetries = 2;
        
        while (retryCount <= maxRetries) {
          try {
            adkWebResult = await sbx.commands.run('cd workspace && ./start_adk.sh', { 
              timeoutMs: 120000,  // 2 minutes timeout to match port checking
              shell: true,
              env: {
                GOOGLE_API_KEY: process.env.GOOGLE_API_KEY,
                ADK_API_KEY: process.env.ADK_API_KEY
              }
            });
            
            // If we get here without throwing, the startup was successful
            break;
            
          } catch (startupError) {
            retryCount++;
            console.log(`‚ùå ADK startup attempt ${retryCount} failed:`, startupError.message);
            
            if (retryCount <= maxRetries) {
              console.log(`üîÑ Retrying ADK startup (attempt ${retryCount + 1}/${maxRetries + 1})...`);
              
              // Clean up any leftover processes before retry
              try {
                await sbx.commands.run('pkill -f "adk web" 2>/dev/null || true', { timeoutMs: 10000 });
                await sbx.commands.run('sleep 3', { timeoutMs: 5000 });
              } catch (cleanupError) {
                console.log('‚ö†Ô∏è Cleanup warning:', cleanupError.message);
              }
            } else {
              // All retries exhausted, try a simpler fallback approach
              console.log('üîÑ Attempting fallback startup method...');
              try {
                // Simple direct startup without the complex script
                await sbx.commands.run(
                  'cd workspace && source venv/bin/activate && export GOOGLE_API_KEY=' + 
                  (process.env.GOOGLE_API_KEY || 'AIzaSyABISxaNzifdIcZUCe408LoKnEz0bia8cI') + 
                  ' && timeout 60 adk web --host 0.0.0.0 --port 8000 --app agent_package &', 
                  { timeoutMs: 70000 }
                );
                
                // Wait a bit for the fallback to start
                await sbx.commands.run('sleep 10', { timeoutMs: 15000 });
                
                // Check if the fallback worked
                const fallbackCheck = await sbx.commands.run('curl -s -o /dev/null -w "%{http_code}" http://localhost:8000 || echo "Failed"', { timeoutMs: 5000 });
                if (fallbackCheck.stdout !== "Failed") {
                  adkWebResult = { stdout: 'Fallback startup successful', stderr: '', exitCode: 0 };
                  console.log('‚úÖ Fallback startup method succeeded');
                  break;
                }
              } catch (fallbackError) {
                console.log('‚ùå Fallback method also failed:', fallbackError.message);
              }
              
              throw new Error(`ADK web server failed to start after ${maxRetries + 1} attempts`);
            }
          }
        }
        
        console.log('üìã ADK web server startup output:');
        if (adkWebResult.stdout) console.log(adkWebResult.stdout);
        if (adkWebResult.stderr) console.log(adkWebResult.stderr);
        
        // Verify server is running using curl
        const serverCheck = await sbx.commands.run('curl -s -o /dev/null -w "%{http_code}" http://localhost:8000 || echo "Failed"', { timeoutMs: 5000 });
        if (serverCheck.stdout === "Failed") {
          throw new Error('ADK web server failed to start - could not connect to port 8000');
        }
        
        console.log('‚úÖ ADK web server started successfully');
        
        // Get the public URL for the ADK web server (port 8000)
        const hostName = sbx.getHost(8000);
        const serverUrl = `https://${hostName}`;
        
        // Create agent-specific URL with proper query parameters
        const agentEndpoint = new URL(serverUrl);
        agentEndpoint.searchParams.set('app', 'agent_package');
        const agentUrl = agentEndpoint.toString();
        
        // Try to verify the server is actually responding
        try {
          const healthCheck = await sbx.commands.run(`curl -s -o /dev/null -w "%{http_code}" http://localhost:8000 || echo "Failed to connect"`);
          console.log(`‚úÖ HTTP server response check: ${healthCheck.stdout}`);
        } catch (error) {
          console.log('‚ö†Ô∏è Could not verify HTTP server response');
        }
        
        // Format the response with enhanced information for the frontend
        const finalResponse = {
          output: `üöÄ Agent successfully deployed and accessible!\n\nüìä Deployment Details:\n‚Ä¢ Agent Package: agent_package\n‚Ä¢ Server Status: Running\n‚Ä¢ Access URL: ${agentUrl}\n\nüîó Click "Open Agent UI" to interact with your agent.`,
          error: null,
          executionTime: Date.now() - startTime,
          memoryUsage: process.memoryUsage().heapUsed / 1024 / 1024, // in MB
          executionDetails: {
            stdout: [`Agent deployed successfully with ADK web interface`],
            stderr: [],
            exitCode: 0,
            status: 'running',
            duration: Date.now() - startTime,
            serverUrl: agentUrl // Use the agent-specific URL
          },
          // Enhanced fields for the frontend CodeGenerationModal
          openUrl: agentUrl,
          showOpenLink: true,
          linkText: 'Open Agent UI',
          agentPackage: 'agent_package',
          deployment: {
            status: 'success',
            url: agentUrl,
            timestamp: new Date().toISOString(),
            package: 'agent_package'
          }
        };

        console.log('üìä Execution Results:');
        console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
        
        console.log(`üöÄ Agent successfully deployed!`);
        console.log(`üìä Deployment details:`);
        console.log(`‚Ä¢ Package: ${finalResponse.agentPackage}`);
        console.log(`‚Ä¢ Status: ${finalResponse.executionDetails.status}`);
        console.log(`‚Ä¢ Duration: ${finalResponse.executionDetails.duration} ms`);
        console.log(`‚Ä¢ Agent URL: ${finalResponse.executionDetails.serverUrl}`);

        console.log('\nüìà Execution Metadata:');
        console.log(`‚Ä¢ Execution Time: ${finalResponse.executionTime}ms`);
        console.log(`‚Ä¢ Memory Usage: ${finalResponse.memoryUsage.toFixed(2)}MB`);
        console.log(`‚Ä¢ Deployment Status: ${finalResponse.deployment.status}`);
        console.log(`‚Ä¢ Access URL: ${finalResponse.deployment.url}`);
        
        res.status(200).json(finalResponse);
          
      } catch (error) {
        console.error('\n‚ùå Error running ADK web command:');
        console.error(error);
        
        // Cleanup sandbox
        try {
          if (sbx) {
            console.log('üßπ Cleaning up sandbox after error...');
            
            // Try to kill the ADK web process if it's running
            try {
              const killResult = await sbx.commands.run('if [ -f workspace/adk_web.pid ]; then kill $(cat workspace/adk_web.pid) 2>/dev/null || true; rm workspace/adk_web.pid; fi', { timeoutMs: 10000 });
              console.log('üìã ADK web kill result:', killResult.stdout || 'No output');
            } catch (killError) {
              console.error('Failed to kill ADK web process:', killError.message);
            }
            
            // Destroy the sandbox
            if (typeof sbx.destroy === 'function') {
              await sbx.destroy();
            } else if (typeof sbx.close === 'function') {
              await sbx.close();
            }
            console.log('‚úÖ Sandbox cleaned up after error');
          }
        } catch (cleanupError) {
          console.error('Error cleaning up sandbox after error:', cleanupError);
        }
        
        return res.status(500).json({
          error: error instanceof Error ? error.message : 'Error running ADK web command',
          executionTime: Date.now() - startTime
        });
      }
      
    } finally {
      // Final cleanup - always try to cleanup sandbox
      try {
        if (sbx) {
          console.log('üßπ Final sandbox cleanup...');
          if (typeof sbx.destroy === 'function') {
            await sbx.destroy();
          } else if (typeof sbx.close === 'function') {
            await sbx.close();
          }
        }
      } catch (cleanupError) {
        console.error('Error in final cleanup:', cleanupError);
      }
    }
    
  } catch (error) {
    console.error('\n‚ùå Sandbox execution error:');
    console.error('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
    console.error(error);
    
    const errorResponse = {
      error: error instanceof Error ? error.message : 'Unknown error occurred',
      stack: error instanceof Error ? error.stack : undefined,
      executionTime: Date.now() - startTime,
      errorDetails: {
        name: error instanceof Error ? error.name : 'Unknown',
        message: error instanceof Error ? error.message : String(error),
        stack: error instanceof Error ? error.stack : undefined,
        code: error instanceof Error ? (error.code || 'UNKNOWN') : 'UNKNOWN'
      }
    };
    
    console.error('\nüìà Error Metadata:');
    console.error(`‚Ä¢ Error Type: ${errorResponse.errorDetails.name}`);
    console.error(`‚Ä¢ Error Code: ${errorResponse.errorDetails.code}`);
    console.error(`‚Ä¢ Execution Time: ${errorResponse.executionTime}ms`);
    console.error('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n');
    
    return res.status(500).json(errorResponse);
  }
});

// Health check endpoint
app.get('/api/health', (req, res) => {
  res.status(200).json({ 
    status: 'ok', 
    message: 'Server is running',
    timestamp: new Date().toISOString()
  });
});

// Home route with API info
app.get('/', (req, res) => {
  res.status(200).json({
    name: 'Agent Flow Builder API',
    version: '1.0.0',
    endpoints: [
      { method: 'POST', path: '/api/execute', description: 'Execute code in sandbox' },
      { method: 'GET', path: '/api/health', description: 'Health check endpoint' }
    ],
    note: "This is a Vercel-compatible version with limited functionality. File operations that require local filesystem won't work."
  });
});

// Export for Vercel serverless function
export default app;

// Start the server if not being imported
if (process.env.NODE_ENV !== 'vercel') {
  app.listen(PORT, () => {
    console.log(`üöÄ Server is running on http://localhost:${PORT}`);
  });
}
